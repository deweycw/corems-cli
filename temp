    let scheduler = thread::spawn(|| {
        let wait_time = Duration::from_millis(500);
            loop {
                let thread_a = thread::spawn(print_out);

                thread_a.join().expect("Thread A panicked");

                thread::sleep(wait_time);

            }
    });

    scheduler.join().expect("Scheduler panicked");

    let mut docker_compose = String::from("\\Users\\");
    let str_split: Vec<&str> = remote_host.split("@").collect();
    let user_home = str_split[0];
    docker_compose.push_str(user_home);
    docker_compose.push_str("\\.corems_cli_transfer\\");
    docker_compose.push_str("docker-compose.yml\\");

    let mut log_file = String::from("\\Users\\");
    let str_split: Vec<&str> = remote_host.split("@").collect();
    let user_home = str_split[0];
    log_file.push_str(user_home);
    log_file.push_str("\\.corems_cli_transfer\\");
    log_file.push_str("log.txt");
    println!("{}",log_file);


    let mut check_log_exists = session.command("wsl.exe")
    .arg("test")
    .arg("-f")
    .arg(&log_out)
    .raw_arg("||")
    .arg("touch")
    .arg(&log_out)
    .output().await?;
    io::stdout().write_all(&check_log_exists.stdout).unwrap();
    io::stderr().write_all(&check_log_exists.stderr).unwrap();


    

    let mut move_data = &session.command("wsl.exe")
        .raw_arg("rsync")
        .arg("-aP")
        .arg(&data_c_path)
        .arg(&wsl_home)
        .output().await?;
    io::stdout().write_all(&move_data.stdout).unwrap();
    io::stderr().write_all(&move_data.stderr).unwrap();






    async fn test() -> bool {
        let sleep1 = sleep(5);
        let task2 = async {
            let sleep2 = sleep(1).await;
            let sleep_arr = vec![sleep(2), sleep(2)];
            futures::future::join_all(sleep_arr).await;
        };
        futures::join!(sleep1, task2);
        return true;
    }
    
    async fn sleep(sec: u64) -> () {
        tokio::time::sleep(std::time::Duration::from_secs(sec)).await;
    }
    
    #[tokio::main]
    async fn main() {
        let instant = std::time::Instant::now();
        test().await;
        dbg!(instant.elapsed());
    }


    let forever = task::spawn(async {
        let mut interval = time::interval(Duration::from_millis(10));

        loop {
            interval.tick().await;
            print_out(&session).await;
        }
    });

    forever.await;


    async fn exec_docker(session: &Session, remote_host: &str) -> Result< (), Box<dyn std::error::Error + 'static>>{ 
        let sleep1 = sleep(0.5);

        let str_split: Vec<&str> = remote_host.split("@").collect();
        let user_home = str_split[0];
  
        let mut log_out_p = String::from("/home/"); 
        log_out_p.push_str(user_home); 
        log_out_p.push_str("/corems_cli_transfer/log.out");

        let mut docker_compose = String::from("/home/");
        docker_compose.push_str(user_home);
        docker_compose.push_str("/corems_cli_transfer/docker-compose.yml");

        println!("{}",docker_compose);
        let mut wsl = session.command("wsl.exe")
            .arg("-e")
            .raw_arg("\"sudo docker compose -f /home/deweyc/corems_cli_transfer/docker-compose.yml up -d |& tee -a /home/deweyc/corems_cli_transfer/log.out\"")
            //.args(["sudo","docker","compose","-f",&docker_compose, "up","-d", "'>", &log_out_p])
            .spawn().await?;

        let print_out = async {
            let sleep2 = sleep(0.1).await;
            let sleep_arr = vec![sleep(0.2), sleep(0.2)];

            let str_split: Vec<&str> = remote_host.split("@").collect();
            let user_home = str_split[0];
    
            let mut log_out_p = String::from("/home/"); 
            log_out_p.push_str(user_home); 
            log_out_p.push_str("/corems_cli_transfer/log.out");
            
            println!("Testing");

            let mut print_tail = session.command("wsl.exe")
                .args(["sudo","tail","-f",&log_out_p])
                .output().await?;
            io::stdout().write_all(&print_tail.stdout).unwrap();
            io::stderr().write_all(&print_tail.stderr).unwrap();

            futures::future::join_all(sleep_arr).await;
        };
        futures::join!(sleep1, print_out);
        Ok(())
    }

    async fn print_out(session: &Session, remote_host: &str) -> Result< (), Box<dyn std::error::Error + 'static>>{
        let str_split: Vec<&str> = remote_host.split("@").collect();
        let user_home = str_split[0];

        let mut log_out_p = String::from("/home/"); 
        log_out_p.push_str(user_home); 
        log_out_p.push_str("/corems_cli_transfer/log.out");

        let mut print_tail = session.command("wsl.exe")
            .args(["sudo","tail","-f",&log_out_p])
            .output().await?;
        io::stdout().write_all(&print_tail.stdout).unwrap();
        io::stderr().write_all(&print_tail.stderr).unwrap();
        Ok(())



        let forever = task::spawn(async {
            let mut interval = time::interval(Duration::from_millis(10));
            let session2 = Session::connect_mux(remote_host, KnownHosts::Accept).await?;

            loop {
                interval.tick().await;
                print_out(&session2).await;
            }
        });
    
        forever.await;